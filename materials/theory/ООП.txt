##############################################################################################################################################################################
Классы и объекты в Python

Объект = данные + код
Класс - это тип объекта

class Goat:
   age = 0         # Атрибуты класса
   name = ''
   weight = 0.0
   def show(self):
    """ Функция в классе называется 'метод класса'
        self - обязателен, это ссылка на объект, для которого вызван этот метод.
    """
        print(self.name)
        print(self.age)
        print(self.age)

# Объект - экземпляр класса (одно из определений)
a = Goat()
a.name = "Нотка"
a.age = 2
a.age += 1

b = Goat()
a.name = "Зорька"
b.age = 1

a.show()
b.show()
# Если мы хотим усовершенствовать козу, то мы меняем класс козы. Это - инкапсуляция ответственности.

##############################################################################################################################################################################

class Student:
    def __init__(self,name,age):
        # Это конструктор. Новые атрибуты нужно создавать только тут!
        self.name = name
        self.age = age
        print(name,'+') # Конструктор может что-то делать



a.Student("Вася", 17) # Хотим получать параметры конструирования, нам нужен конструирующий метод. В ("Вася", 17) мы передаём параметры конструктору.
# Есть экземплярные атрибуты (зазаются к конкретному экземпляру) и абстрактые (классовые) (атрибуты в конструкторе).


##############################################################################################################################################################################
SOLID принципы

1) Один из них - принцип единственной ответсвеннсти класса - у каждого класса одна обязанность (но это не закон). Должна быть только одна причина для изменения класса.
2) KISS - keep it simple stupid - оставь это простым! Плоский тип реализации может быть лучше, чем иерархический.