##############################################################################################################################################################################
Классы и объекты в Python

Объект = данные + код
Класс - это тип объекта

class Goat:
   age = 0         # Атрибуты класса
   name = ''
   weight = 0.0
   def show(self):
    """ Функция в классе называется 'метод класса'
        self - обязателен, это ссылка на объект, для которого вызван этот метод.
    """
        print(self.name)
        print(self.age)
        print(self.age)

# Объект - экземпляр класса (одно из определений)
a = Goat()
a.name = "Нотка"
a.age = 2
a.age += 1

b = Goat()
a.name = "Зорька"
b.age = 1

a.show()
b.show()
# Если мы хотим усовершенствовать козу, то мы меняем класс козы. Это - инкапсуляция ответственности.

##############################################################################################################################################################################

class Student:
    def __init__(self,name,age):
        # Это конструктор. Новые атрибуты нужно создавать только тут!
        self.name = name
        self.age = age
        print(name,'+') # Конструктор может что-то делать



a.Student("Вася", 17) # Хотим получать параметры конструирования, нам нужен конструирующий метод. В ("Вася", 17) мы передаём параметры конструктору.
# Есть экземплярные атрибуты (зазаются к конкретному экземпляру) и абстрактые (классовые) (атрибуты в конструкторе).


##############################################################################################################################################################################
SOLID принципы

1) Один из них - принцип единственной ответсвеннсти класса - у каждого класса одна обязанность (но это не закон). Должна быть только одна причина для изменения класса.
2) KISS - keep it simple stupid - оставь это простым! Плоский тип реализации может быть лучше, чем иерархический.



# https://www.youtube.com/watch?v=DxNu5A_TRN4&list=PLRDzFCPr95fLuusPXwvOPgXzBL3ZTzybY&index=12
Связи между классами: ассоциация, может быть направлена. Если классы являются дочерними, то их отношение к родительскому != ассоциация, это частный случай, который может
наследовать методы родительского метода.
doctest - модуль для тестирования.

Проблема композиции (интеграции):
    1) компиляия (строгая промерка типов)
    2) использование контрактов:
        - предусловия
        - постусловия
        - инварианты
Эта идея наз. проектирование (программирование) по контракту (DbC - dtsign by contract).


##############################################################################################################################################################################
Тестирование - проверка соответствий между реальным поведением программы и её ожидаемым поведением.
Тестирование проводится на конечном наборе тестов (test case), выбранном определённом образом.
Аспекты качества: 
    1) функциональность
    2) надёжность
    3) практичность 
    4) эффективность
    5) сопровождаемость
    6) переносимость
Масшаты тестирования:
    1) модульное тестирование (unit testing, тестирование отдельного модуля)
    2) интеграционное тестирование (про взаимодействие модулей)
    3) системное тестирование (тестирование всей системы целиком)
unittest - стандартный либ для модульного тестирования.