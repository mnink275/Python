# https://www.youtube.com/watch?v=kCQfhRReGTI&list=PLRDzFCPr95fLuusPXwvOPgXzBL3ZTzybY&index=5
"Структурное" программирование:
 1) Программирование - это:
    1) последовательное пограммирование
    2) ветвление
    3) циклы
    4) НЕТ goto! Это запутанно. Должно быть видно, что видно
2) Повторяющийся код - отправляй в функции. Происходит "рефакторинг" кода и его "декомпозиция".
3) Программируй "сверху - вниз".


Консистентное состояние - программа без ошибок. Если пытаться написать всё сразу, а потом запустить, то это будет = большому скачку на ----> t.
Так делать нельзя. Делай программу небольшими, но устойчивыми итерациями. Это "итеративный подход". Количество наших commit`ов в наших руках.

Нужно узнать параметры задачи, а не бросаться в бой -> делигирование и декомпозиция.
Делигирование - когда кто-нибудь перекладывает ответственность. Делигирование полномочий, делигирование ответственности.
Делигирование подзадачи - программа задаёт параметры подпрограмме, а подпрограмма решает задачу в соответствие с ними:
    paint_house(x,y,width,height)
Между ними возникает "интерфейс вызова", который имеет "контракт": ширина и высота не должна быть отрицательной и т.д. При вызове функции мы должны иметь
возможность прочитать, что конкретно имеется ввиду под параметрами функции.

Пример, пишем в коде: 
    paint_house(1,5,10,10)
Это неконсистентное состояние. Для наиболее быстрого приземление можно использовать "мошенника" (зашлушку) и прокомментировать, что делают параметры и функции. Создадим функцию:
    def paint_house(x,y,width,height):
        """ Нарисовать домик:
            (x,y) - левая точка крыши """
        pass
    paint_house(1,5,10,10)

Функция не будет ничего делать, но программу уже можно будет закоммитить, потому что она стала консистентной.

Теперь "модернезируем" заглушку.
    def paint_house(x,y,width,height):
        """ Нарисовать домик:
            (x,y) - левая точка крыши """
        paint_walls(x,y,width,height//2) #вызываем пригадира, который делает стены
        paint_roof(x,y,width,height//2)  #делает крышу
        w_height = height // 6
        w_width = width // 3
        paint_window(x + w_width,y + w_height,
                    w_width,w_height)
    paint_house(1,5,10,10)



##############################################################################################################################################################################


# https://www.youtube.com/watch?v=enbhOrC2Vzo&list=PLRDzFCPr95fLuusPXwvOPgXzBL3ZTzybY&index=5
"Событийно-ориентированное" программирование
 Приложение просыпается (система выделяет ей процессорное время) для "обработки события".
 # tkinter, pygame
 # Идея - повторить игру зерг рага гугла, т.е. игра "кликни шарик"

##############################################################################################################################################################################

"Декомпозиция проекта"
1) функции
2) Модули/Пакеты
3) Объекты

1) В процессе работы функций становится много и файл разрастается. Идея - разнести функции по отдельным кусочкам - "модулям". Пример: main.py(главный), view.py(графика),
model.py(физика модели), .... Модключение модулей друг к другу: import view -> view.foo(5). Это также позволяет создавать функции с одинаковым названием в разных модулях.
Если выделить ...py в отдельную директорию, то получится "пакет". Зависимость модулей .py друг от друга нужно продумать самостоятельно. Это - архитектура программы.
Ключевые темы meet ups:
1) архитектура программы
2) интерфейсы модулей
3) ответственность модулей

Правило LEGB - Local Enclosing Global Built-in - приоритет использования значения "имени" в порядке убывания. Сначала исплоьзуется "x" подфункции. Если нет, то "x" функции. И т.д.
